image:
  repository: trinodb/trino
  tag: 380
  pullPolicy: IfNotPresent
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000

imagePullSecrets: []
# For example:
# imagePullSecrets:
#   - name: registry-credentials

ingress:
  enabled: true
  ingressClassName: nginx
  annotations: {}
    # kubernetes.io/ingress.class: nginx
  host: trino-stag.dp.vng.vn
  tls:
    secretName:

clusterDomain: cluster.local

config:
  general:
    node:
      environment: production
      dataDir: /data/trino
      pluginDir: /usr/lib/trino/plugin
    log:
      trino:
        level: DEBUG
    path: /etc/trino
    http:
      port: 8080
    processForwarded: true
    # -- Trino supports multiple authentication types: PASSWORD, CERTIFICATE, OAUTH2, JWT, KERBEROS
    # For more info: https://trino.io/docs/current/security/authentication-types.html
    authenticationType: PASSWORD
    catalogsMountType: "secret"
    httpsServer:
      enabled: false
      port: 8443
      keystore:
        path: "/usr/local/certs/clustercoord.pem"
        # JKS keystores always require a password, while PEM format certificates can optionally require a password
        key: ""
    internalCommunicationSharedSecret: 2UzI5lErjoPaH579iAJjlWgv2idbglnE
    query:
      maxMemory: "3GB"
      maxMemoryPerNode: "1GB"
      maxTotalMemory: "6GB"
    prestoCompatibleHeader: false

  coordinator:
    replicas: 1
    env: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    podAnnotations: {}
    resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi
    initContainers: []
    #   - name: init-coordinator
    #     image: busybox:1.28
    #     imagePullPolicy: IfNotPresent
    #     command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
    jvm:
      maxHeapSize: "24G"
      gcMethod:
        type: "UseG1GC"
        g1:
          heapRegionSize: "32M"
    jvmExtraConfig: ""
    extraConfig: ""

  worker:
    # -- Replica count when autoscaler is disabled. If autoscaler is enabled, it sets minimum number of replicas.
    replicas: 2
    env: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    podAnnotations: {}
    resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi
    initContainers: []
    # worker:
    #   - name: init-worker
    #     image: busybox:1.28
    #     command: ['sh', '-c', 'echo The worker is running! && sleep 3600']
    jvm:
      maxHeapSize: "10G"
      gcMethod:
        type: "UseG1GC"
        g1:
          heapRegionSize: "32M"
    jvmExtraConfig: ""
    extraConfig: ""
    autoscaler:
      enabled: true
      maxReplicas: 5
      targetCPUUtilizationPercentage: 80
      stabilizationWindowSeconds: 300

eventListenerProperties: {}

auth:
  # Set username and password
  # https://trino.io/docs/current/security/password-file.html#file-format
  passwordAuth: "admin:$2y$10$0msB8DgFlFTLQ.X8Ggz7k.8s.lOLc..3L6ml/KWsr2qeI0mDjdspG\n" # INPUT user:hashed_password

accessControl: {}

resourceGroups: {}

# If you want to provide your own secrets resource, you can use this field:
# connectorsSecret:

groupProvider: {}

faultTolerance:
  enabled: false

hive-metastore: 
  enabled: true
  postgresql:
    postgresqlPassword: "postgres" # INPUT postgresqlPassword
  conf:
    hiveSite:
      hive.metastore.warehouse.dir: s3a://testtrino-d9sgw/trinoquery # INPUT hive.metastore.warehouse.dir
      fs.s3a.access.key: TJPQ58NEBSF5JH4MM5U8  # INPUT fs.s3a.access.key
      fs.s3a.secret.key: hgW0LpqSurlThfyQcBy0c9ZiiNuxmkPMQOh6gKXi # INPUT fs.s3a.secret.key
      fs.s3a.endpoint: https://s3.dp.vng.vn # INPUT fs.s3a.endpoint

connectors:
  # Connectors configuration usually contains sensitive data (like passwords, usernames, ...)
  # so data is stored in a secret
  hive.properties: |- # INPUT hive_properties
    connector.name=hive
    hive.metastore.uri=thrift://hive-metastore:9083
    hive.s3.aws-access-key=TJPQ58NEBSF5JH4MM5U8
    hive.s3.aws-secret-key=hgW0LpqSurlThfyQcBy0c9ZiiNuxmkPMQOh6gKXi
    hive.s3.endpoint=https://s3.dp.vng.vn

catalogs: {}

schemas: {}

service:
  type: ClusterIP

secretMounts: []

configMapMounts: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

initKeystore:
  image:
    repository: bitnami/java
    tag: 17
    pullPolicy: IfNotPresent

tls:
  # Set internode encryption
  internodeEncryption: false
  # Generate automatically self-signed TLS certificates. Currently only supports PEM certificates
  autoGenerated: false
  # Existing secret that contains the keystore
  existingKeystoreSecret: ""
  # Existing secret that contains the cert and key for the keystore
  tlsEncryptionSecretName: ""
  # Existing secret that contains the password to the keystore
  keystorePasswordSecret: ""
  resources: {}
    # limits:
    #  cpu: 100m
    #  memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 128Mi

jmxExporter:
  coordinator:
    enabled: false
  worker:
    enabled: false
  port: 9000
  path: /prometheus
  jarfile: jmx_prometheus_javaagent-0.17.2.jar
  downloadLink: https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.17.2/jmx_prometheus_javaagent-0.17.2.jar
  image:
    repository: curlimages/curl
    tag: 7.87.0
    pullPolicy: IfNotPresent
  serviceMonitor:
    enabled: true
    port: "jmx-exporter"
    additionalLabels: {}
    interval: 1m
    scrapeTimeout: 10s
    path: /metrics
    # Additional relabeling configs to the ones that Prometheus Operator
    # creates by default.
    # relabelings:
    #   - sourceLabels: [__meta_kubernetes_endpoints_label_app_kubernetes_io_version]
    #     targetLabel: version
